<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">Game Page</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    </style>
</head>

<body>
    <div id="infomation-container">
        <canvas id="infomation" width="800" height="100"></canvas>
    </div>
    <div id="board-container" style="width: 800px; height: 800px; margin-bottom: 20px;">
        <canvas id="board" width="800" height="800"></canvas>
    </div>
    <div id="confidence-chart-container" style="width: 800px; height: 50px; margin-bottom: 20px;">
        <canvas id="confidence-chart" width="800" height="50"></canvas>
    </div>

    </div>

    <script>
        const GameData = []
        const socket = io('http://localhost:2468');
        const gobanVisual = document.getElementById('board');
        const gobaContext = gobanVisual.getContext('2d');

        const confidenceChart = document.getElementById('confidence-chart')
        const confContext = confidenceChart.getContext('2d')

        const playerInfo = document.getElementById('infomation')
        const infoContext = playerInfo.getContext('2d');

        // Double the internal size of the board
        gobanVisual.width = 1600;
        gobanVisual.height = 1600;

        // But keep the display size
        gobanVisual.style.width = '800px';
        gobanVisual.style.height = '800px';

        confidenceChart.width = 1600
        confidenceChart.height = 100

        confidenceChart.style.width = '800px'
        confidenceChart.style.height = '50px'

        playerInfo.width = 1600
        playerInfo.height = 200

        playerInfo.style.width = '800px'
        playerInfo.style.height = '100px'

        // Now you need to scale the drawing context
        gobaContext.scale(2, 2);
        confContext.scale(2, 2);
        infoContext.scale(2, 2);

        function drawBoard({ moves, lastMove, aiMoves }) {
            const padding = 20;
            const boardSize = 800;
            const cellSize = boardSize / 19;
            const totalSize = boardSize + 2 * padding;  // Total canvas size including padding
            const letters = 'ABCDEFGHJKLMNOPQRST';
            // Draw background
            gobaContext.fillStyle = '#FFCC66';  // This is a light brown color
            gobaContext.fillRect(0, 0, totalSize, totalSize);

            // Draw lines centered with padding
            for (let i = 0; i < 19; i++) {
                gobaContext.beginPath();

                // Horizontal Lines
                gobaContext.moveTo(padding, padding + i * cellSize);
                gobaContext.lineTo(boardSize - padding - 2, padding + i * cellSize);

                // Vertical Lines
                gobaContext.moveTo(padding + i * cellSize, padding);
                gobaContext.lineTo(padding + i * cellSize, boardSize - padding - 2);

                gobaContext.strokeStyle = '#000';
                gobaContext.stroke();

                gobaContext.font = '16px Arial';  // You can adjust the font size and style as needed
                gobaContext.textAlign = 'center';
                gobaContext.textBaseline = 'middle';
                gobaContext.fillStyle = '#000';  // Text color
                // Add letter labels for horizontal lines
                gobaContext.fillText(letters.charAt(i), padding + i * cellSize, boardSize - padding + 10); // The '-4' and '+15' are offsets to position the letters correctly
                // Add number labels for vertical lines (from 19 down to 1)
                gobaContext.fillText(String(19 - i), 8, padding + i * cellSize);  // The '4' offsets are to position the numbers correctly
            }

            const stoneRadius = cellSize / 1.65 - 5;

            for (let y = 0; y < 19; y++) {
                for (let x = 0; x < 19; x++) {
                    const color = moves[y][x];
                    if (color === '') continue;  // skip empty intersections

                    // Draw the full stone:
                    gobaContext.beginPath();
                    gobaContext.arc(padding + x * cellSize, padding + y * cellSize, stoneRadius, 0, Math.PI * 2, false);
                    gobaContext.strokeStyle = 'black';
                    gobaContext.lineWidth = 2;

                    if (color === 'b') {
                        gobaContext.fillStyle = 'black';
                    } else if (color === 'w') {
                        gobaContext.fillStyle = 'white';
                    } else if (color === 'a') {
                        gobaContext.fillStyle = 'lightblue';
                    }
                    gobaContext.fill();
                    gobaContext.stroke();
                }
            }

            console.log(lastMove)
            if (lastMove) {
                const x = lastMove[1]
                const y = lastMove[2]
                gobaContext.beginPath();
                gobaContext.arc(padding + x * cellSize, padding + y * cellSize, stoneRadius / 2, 0, Math.PI * 2, false);
                gobaContext.strokeStyle = "red"
                gobaContext.lineWidth = 4;
                gobaContext.stroke();  // Only stroking the smaller circle, not filling
            }

            console.log(aiMoves)
            for(let ai = 0; ai < 3; ai++) {
                    const x = aiMoves[ai][1]
                    const y = aiMoves[ai][2]

                    gobaContext.beginPath();
                    gobaContext.arc(padding + x * cellSize, padding + y * cellSize, stoneRadius, 0, Math.PI * 2, false);
                    gobaContext.strokeStyle = 'black';
                    gobaContext.lineWidth = 2;

                    if (ai == 0) {
                        gobaContext.fillStyle = 'blue';
                    } else if (ai == 1) {
                        gobaContext.fillStyle = 'green';
                    } else if (ai == 2) {
                        gobaContext.fillStyle = 'yellow';
                    }

                    gobaContext.fill();
                    gobaContext.stroke();
            }
        }

        function updateEvaluations(evaluations) {
            const evalConfidence = evaluations.confidence
            const winrate = evaluations.winrate
            const territory = evaluations.territory
            const aiScore = evaluations.score
            const lastMoveValue = evaluations.lastMoveValue

            updateWinrate(winrate)
            updateConfidenceChart(evalConfidence)
            updateLastMove(lastMoveValue)
        }


        
        socket.on('connect', () => {
        });

        socket.on('error', (err) => { console.log(err) })

        socket.on('disconnect', () => {
            document.getElementById('status').textContent = 'Disconnected';
        });

        const pathSegments = window.location.pathname.split('/');
        const type = pathSegments[1];
        const id = pathSegments[2];
        const eventName = `${type}/${id}`;
        console.log(eventName)
        document.getElementById('title').textContent = eventName

        socket.on(eventName, (gameData) => {
            const jsonData = JSON.parse(gameData);
            const data = jsonData.data
            console.log(data)
            // drawTopInfo({players: data.players, winrate: data.winrate.ai.current})
            drawBoard({ moves: data.state, lastMove: data.last.move, aiMoves: data.ai.colors })
            // drawConfidence({black: data.confidence.black, white: data.confidence.white})
        });


    </script>
</body>

</html>